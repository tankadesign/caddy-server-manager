package wordpress

import (
	"archive/tar"
	"compress/gzip"
	"crypto/rand"
	"encoding/hex"
	"fmt"
	"io"
	"net/http"
	"os"
	"path/filepath"
	"strings"
)

// WordPressManager handles WordPress-specific operations
type WordPressManager struct {
	Verbose bool
	DryRun  bool
}

// NewWordPressManager creates a new WordPress manager
func NewWordPressManager(verbose, dryRun bool) *WordPressManager {
	return &WordPressManager{
		Verbose: verbose,
		DryRun:  dryRun,
	}
}

// DownloadAndExtract downloads the latest WordPress and extracts it to the target directory
func (wm *WordPressManager) DownloadAndExtract(targetDir string) error {
	if wm.DryRun {
		if wm.Verbose {
			fmt.Printf("Would download and extract WordPress to: %s\n", targetDir)
		}
		return nil
	}

	if wm.Verbose {
		fmt.Println("Downloading latest WordPress...")
	}

	// Download WordPress
	resp, err := http.Get("https://wordpress.org/latest.tar.gz")
	if err != nil {
		return fmt.Errorf("failed to download WordPress: %v", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return fmt.Errorf("failed to download WordPress: HTTP %d", resp.StatusCode)
	}

	// Create gzip reader
	gzipReader, err := gzip.NewReader(resp.Body)
	if err != nil {
		return fmt.Errorf("failed to create gzip reader: %v", err)
	}
	defer gzipReader.Close()

	// Create tar reader
	tarReader := tar.NewReader(gzipReader)

	if wm.Verbose {
		fmt.Printf("Extracting WordPress to: %s\n", targetDir)
	}

	// Extract files
	for {
		header, err := tarReader.Next()
		if err == io.EOF {
			break
		}
		if err != nil {
			return fmt.Errorf("failed to read tar entry: %v", err)
		}

		// Remove "wordpress/" prefix from path
		path := strings.TrimPrefix(header.Name, "wordpress/")
		if path == "" {
			continue // Skip the wordpress/ directory itself
		}

		target := filepath.Join(targetDir, path)

		switch header.Typeflag {
		case tar.TypeDir:
			if err := os.MkdirAll(target, os.FileMode(header.Mode)); err != nil {
				return fmt.Errorf("failed to create directory %s: %v", target, err)
			}
		case tar.TypeReg:
			// Ensure parent directory exists
			if err := os.MkdirAll(filepath.Dir(target), 0755); err != nil {
				return fmt.Errorf("failed to create parent directory for %s: %v", target, err)
			}

			file, err := os.OpenFile(target, os.O_CREATE|os.O_WRONLY|os.O_TRUNC, os.FileMode(header.Mode))
			if err != nil {
				return fmt.Errorf("failed to create file %s: %v", target, err)
			}

			if _, err := io.Copy(file, tarReader); err != nil {
				file.Close()
				return fmt.Errorf("failed to write file %s: %v", target, err)
			}
			file.Close()
		}
	}

	if wm.Verbose {
		fmt.Println("WordPress extracted successfully")
	}

	return nil
}

// GenerateSecureConfig generates a secure wp-config.php file with latest best practices
func (wm *WordPressManager) GenerateSecureConfig(targetDir, dbName, dbUser, dbPassword string) error {
	if wm.DryRun {
		if wm.Verbose {
			fmt.Printf("Would generate wp-config.php in: %s\n", targetDir)
		}
		return nil
	}

	if wm.Verbose {
		fmt.Println("Generating secure wp-config.php...")
	}

	// Get WordPress salts
	saltKeys, err := wm.getWordPressSalts()
	if err != nil {
		return fmt.Errorf("failed to get WordPress salts: %v", err)
	}

	// Generate additional security keys
	securityKeys, err := wm.generateSecurityKeys()
	if err != nil {
		return fmt.Errorf("failed to generate security keys: %v", err)
	}

	wpConfigContent := fmt.Sprintf(`<?php
/**
 * WordPress Configuration File
 * 
 * This file contains the following configurations:
 * - Database settings
 * - Security keys and salts
 * - Security hardening
 * - Performance optimizations
 * 
 * Generated by Caddy Site Manager
 */

// ** Database Configuration ** //
define( 'DB_NAME', '%s' );
define( 'DB_USER', '%s' );
define( 'DB_PASSWORD', '%s' );
define( 'DB_HOST', 'localhost' );
define( 'DB_CHARSET', 'utf8mb4' );
define( 'DB_COLLATE', '' );

// ** Security Keys and Salts ** //
%s

// ** Additional Security Keys ** //
%s

// ** Table Prefix ** //
$table_prefix = 'wp_';

// ** Security Hardening ** //

// Disable file editing in WordPress admin
define( 'DISALLOW_FILE_EDIT', true );

// Disable plugin and theme installation/deletion
define( 'DISALLOW_FILE_MODS', false ); // Set to true for production

// Disable WordPress auto-updates for better control
define( 'AUTOMATIC_UPDATER_DISABLED', false );
define( 'WP_AUTO_UPDATE_CORE', 'minor' ); // Only minor updates

// Security headers and SSL
define( 'FORCE_SSL_ADMIN', true );

// ** Performance Optimizations ** //

// Increase memory limit
define( 'WP_MEMORY_LIMIT', '512M' );

// Enable WP Cron optimization
define( 'DISABLE_WP_CRON', false );

// Increase timeout for WordPress operations
define( 'WP_HTTP_BLOCK_EXTERNAL', false );

// ** Debug Settings ** //
define( 'WP_DEBUG', false );
define( 'WP_DEBUG_LOG', false );
define( 'WP_DEBUG_DISPLAY', false );
define( 'SCRIPT_DEBUG', false );

// ** Cookie Settings ** //
define( 'COOKIE_DOMAIN', '.%s' );

// ** Multisite Settings (if needed in future) ** //
// define( 'WP_ALLOW_MULTISITE', false );

/* That's all, stop editing! Happy publishing. */

/** Absolute path to the WordPress directory. */
if ( ! defined( 'ABSPATH' ) ) {
    define( 'ABSPATH', __DIR__ . '/' );
}

/** Sets up WordPress vars and included files. */
require_once ABSPATH . 'wp-settings.php';
`, dbName, dbUser, dbPassword, saltKeys, securityKeys, getDomainFromPath(targetDir))

	wpConfigFile := filepath.Join(targetDir, "wp-config.php")
	if err := os.WriteFile(wpConfigFile, []byte(wpConfigContent), 0600); err != nil {
		return fmt.Errorf("failed to create wp-config.php: %v", err)
	}

	// Create robots.txt for basic SEO
	if err := wm.createRobotsTxt(targetDir); err != nil {
		return fmt.Errorf("failed to create robots.txt: %v", err)
	}

	if wm.Verbose {
		fmt.Println("Secure WordPress configuration created")
	}

	return nil
}

// getWordPressSalts fetches authentication keys and salts from WordPress.org
func (wm *WordPressManager) getWordPressSalts() (string, error) {
	resp, err := http.Get("https://api.wordpress.org/secret-key/1.1/salt/")
	if err != nil {
		// Fallback to local generation if API is unavailable
		return wm.generateLocalSalts()
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		// Fallback to local generation if API returns error
		return wm.generateLocalSalts()
	}

	salts, err := io.ReadAll(resp.Body)
	if err != nil {
		return wm.generateLocalSalts()
	}

	return string(salts), nil
}

// generateLocalSalts generates salts locally if the WordPress API is unavailable
func (wm *WordPressManager) generateLocalSalts() (string, error) {
	saltNames := []string{
		"AUTH_KEY",
		"SECURE_AUTH_KEY",
		"LOGGED_IN_KEY",
		"NONCE_KEY",
		"AUTH_SALT",
		"SECURE_AUTH_SALT",
		"LOGGED_IN_SALT",
		"NONCE_SALT",
	}

	var salts strings.Builder
	for _, name := range saltNames {
		salt, err := wm.generateRandomString(64)
		if err != nil {
			return "", err
		}
		salts.WriteString(fmt.Sprintf("define( '%s', '%s' );\n", name, salt))
	}

	return salts.String(), nil
}

// generateSecurityKeys generates additional security configuration
func (wm *WordPressManager) generateSecurityKeys() (string, error) {
	// Generate unique security token
	securityToken, err := wm.generateRandomString(32)
	if err != nil {
		return "", err
	}

	// Generate session cookie name
	sessionCookie, err := wm.generateRandomString(16)
	if err != nil {
		return "", err
	}

	securityConfig := fmt.Sprintf(`// Custom security token for this installation
define( 'WP_SECURITY_TOKEN', '%s' );

// Custom session cookie name
define( 'WP_SESSION_COOKIE', 'wp_session_%s' );

// Additional security constants
define( 'WP_CACHE', true );
define( 'CONCATENATE_SCRIPTS', true );
`, securityToken, sessionCookie)

	return securityConfig, nil
}

// generateRandomString generates a cryptographically secure random string
func (wm *WordPressManager) generateRandomString(length int) (string, error) {
	bytes := make([]byte, length/2)
	if _, err := rand.Read(bytes); err != nil {
		return "", err
	}
	return hex.EncodeToString(bytes)[:length], nil
}

// createRobotsTxt creates a basic robots.txt file
func (wm *WordPressManager) createRobotsTxt(targetDir string) error {
	robotsContent := `# Robots.txt for WordPress
# Generated by Caddy Site Manager

User-agent: *
Disallow: /wp-admin/
Disallow: /wp-includes/
Disallow: /wp-content/plugins/
Disallow: /wp-content/themes/
Disallow: /trackback/
Disallow: /comments/
Disallow: */trackback/
Disallow: */comments/
Disallow: wp-login.php
Disallow: wp-register.php

# Allow access to WordPress assets
Allow: /wp-content/uploads/
Allow: *.css
Allow: *.js

# Sitemap (uncomment and update when you have a sitemap)
# Sitemap: https://yourdomain.com/sitemap.xml
`

	robotsFile := filepath.Join(targetDir, "robots.txt")
	return os.WriteFile(robotsFile, []byte(robotsContent), 0644)
}

// getDomainFromPath extracts domain from path like /var/www/sites/example.com
func getDomainFromPath(path string) string {
	// Extract the last component of the path, which should be the domain
	parts := strings.Split(strings.TrimSuffix(path, "/"), "/")
	if len(parts) > 0 {
		return parts[len(parts)-1]
	}
	return "localhost"
}

// CleanupOnError removes partially created WordPress installation on error
func (wm *WordPressManager) CleanupOnError(targetDir string) error {
	if wm.DryRun {
		return nil
	}

	if wm.Verbose {
		fmt.Printf("Cleaning up WordPress installation at: %s\n", targetDir)
	}

	return os.RemoveAll(targetDir)
}

// ValidateWordPressInstallation checks if WordPress was properly installed
func (wm *WordPressManager) ValidateWordPressInstallation(targetDir string) error {
	requiredFiles := []string{
		"index.php",
		"wp-config.php",
		"wp-load.php",
		"wp-settings.php",
		"wp-admin/index.php",
		"wp-includes/version.php",
	}

	for _, file := range requiredFiles {
		filePath := filepath.Join(targetDir, file)
		if _, err := os.Stat(filePath); os.IsNotExist(err) {
			return fmt.Errorf("required WordPress file missing: %s", file)
		}
	}

	if wm.Verbose {
		fmt.Println("WordPress installation validation successful")
	}

	return nil
}
